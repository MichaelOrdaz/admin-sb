/* tslint:disable */
/* eslint-disable */
/**
 * SB documentacion
 * Documentacion para api resful s&b
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessCode
 */
export interface AccessCode {
    /**
     * 
     * @type {number}
     * @memberof AccessCode
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccessCode
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AccessCode
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessCode
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessCode
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof AccessCode
     */
    'expeditionDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessCode
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessCode
     */
    'category'?: string;
    /**
     * 
     * @type {Client}
     * @memberof AccessCode
     */
    'client'?: Client;
    /**
     * 
     * @type {string}
     * @memberof AccessCode
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessCode
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface AccessCodeUpdateDto
 */
export interface AccessCodeUpdateDto {
    /**
     * 
     * @type {string}
     * @memberof AccessCodeUpdateDto
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccessCodeUpdateDto
     */
    'user'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccessCodeUpdateDto
     */
    'expeditionDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccessCodeUpdateDto
     */
    'dueDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccessCodeUpdateDto
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface AccessCodesControllerFindAllCodes200Response
 */
export interface AccessCodesControllerFindAllCodes200Response {
    /**
     * 
     * @type {Array<AccessCode>}
     * @memberof AccessCodesControllerFindAllCodes200Response
     */
    'data'?: Array<AccessCode>;
}
/**
 * 
 * @export
 * @interface AccessCodesControllerFindCodeNames200Response
 */
export interface AccessCodesControllerFindCodeNames200Response {
    /**
     * 
     * @type {Array<AccessCodesControllerFindCodeNames200ResponseDataInner>}
     * @memberof AccessCodesControllerFindCodeNames200Response
     */
    'data'?: Array<AccessCodesControllerFindCodeNames200ResponseDataInner>;
}
/**
 * 
 * @export
 * @interface AccessCodesControllerFindCodeNames200ResponseDataInner
 */
export interface AccessCodesControllerFindCodeNames200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof AccessCodesControllerFindCodeNames200ResponseDataInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessCodesControllerFindCodeNames200ResponseDataInner
     */
    'humanizedName'?: string;
}
/**
 * 
 * @export
 * @interface AccessCodesControllerFindOneCode200Response
 */
export interface AccessCodesControllerFindOneCode200Response {
    /**
     * 
     * @type {AccessCode}
     * @memberof AccessCodesControllerFindOneCode200Response
     */
    'data'?: AccessCode;
}
/**
 * 
 * @export
 * @interface Activity
 */
export interface Activity {
    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    'percentage': number;
    /**
     * 
     * @type {Client}
     * @memberof Activity
     */
    'client'?: Client;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface AuthControllerLogin200Response
 */
export interface AuthControllerLogin200Response {
    /**
     * 
     * @type {AuthControllerLogin200ResponseData}
     * @memberof AuthControllerLogin200Response
     */
    'data'?: AuthControllerLogin200ResponseData;
}
/**
 * 
 * @export
 * @interface AuthControllerLogin200ResponseData
 */
export interface AuthControllerLogin200ResponseData {
    /**
     * 
     * @type {User}
     * @memberof AuthControllerLogin200ResponseData
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerLogin200ResponseData
     */
    'access_token'?: string;
}
/**
 * 
 * @export
 * @interface Client
 */
export interface Client {
    /**
     * 
     * @type {number}
     * @memberof Client
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'paternalSurname'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'maternalSurname'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'phone2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'rfc': string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'curp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'outdoorNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'interiorNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'cologne'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'province'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'legalRepresentativeFullname'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'legalRepresentativeRFC'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'legalRepresentativeCURP'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'observations': string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'reasonToInactive': string;
    /**
     * 
     * @type {Array<Activity>}
     * @memberof Client
     */
    'activities'?: Array<Activity>;
    /**
     * 
     * @type {Array<Regime>}
     * @memberof Client
     */
    'regimes'?: Array<Regime>;
    /**
     * 
     * @type {Array<AccessCode>}
     * @memberof Client
     */
    'accessCodes'?: Array<AccessCode>;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface ClientActivitiesDto
 */
export interface ClientActivitiesDto {
    /**
     * 
     * @type {number}
     * @memberof ClientActivitiesDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClientActivitiesDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ClientActivitiesDto
     */
    'percentage': number;
}
/**
 * 
 * @export
 * @interface ClientCodeEfirmaCDSDto
 */
export interface ClientCodeEfirmaCDSDto {
    /**
     * 
     * @type {string}
     * @memberof ClientCodeEfirmaCDSDto
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ClientCodeEfirmaCDSDto
     */
    'expeditionDate': string;
    /**
     * 
     * @type {string}
     * @memberof ClientCodeEfirmaCDSDto
     */
    'dueDate': string;
}
/**
 * 
 * @export
 * @interface ClientCodeOthersDto
 */
export interface ClientCodeOthersDto {
    /**
     * 
     * @type {number}
     * @memberof ClientCodeOthersDto
     */
    'id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ClientCodeOthersDto
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClientCodeOthersDto
     */
    'user'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClientCodeOthersDto
     */
    'expeditionDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClientCodeOthersDto
     */
    'dueDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClientCodeOthersDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClientCodeOthersDto
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface ClientCodeUserPasswordDto
 */
export interface ClientCodeUserPasswordDto {
    /**
     * 
     * @type {string}
     * @memberof ClientCodeUserPasswordDto
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof ClientCodeUserPasswordDto
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface ClientCodeUserPasswordEmailDto
 */
export interface ClientCodeUserPasswordEmailDto {
    /**
     * 
     * @type {string}
     * @memberof ClientCodeUserPasswordEmailDto
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof ClientCodeUserPasswordEmailDto
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ClientCodeUserPasswordEmailDto
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ClientCodesControllerFindAllCodesByClient200Response
 */
export interface ClientCodesControllerFindAllCodesByClient200Response {
    /**
     * 
     * @type {ClientCodesControllerFindAllCodesByClient200ResponseData}
     * @memberof ClientCodesControllerFindAllCodesByClient200Response
     */
    'data'?: ClientCodesControllerFindAllCodesByClient200ResponseData;
}
/**
 * 
 * @export
 * @interface ClientCodesControllerFindAllCodesByClient200ResponseData
 */
export interface ClientCodesControllerFindAllCodesByClient200ResponseData {
    /**
     * 
     * @type {ClientCodesControllerFindAllCodesByClient200ResponseDataClientCodes}
     * @memberof ClientCodesControllerFindAllCodesByClient200ResponseData
     */
    'clientCodes'?: ClientCodesControllerFindAllCodesByClient200ResponseDataClientCodes;
    /**
     * 
     * @type {Client}
     * @memberof ClientCodesControllerFindAllCodesByClient200ResponseData
     */
    'client'?: Client;
}
/**
 * 
 * @export
 * @interface ClientCodesControllerFindAllCodesByClient200ResponseDataClientCodes
 */
export interface ClientCodesControllerFindAllCodesByClient200ResponseDataClientCodes {
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerFindAllCodesByClient200ResponseDataClientCodes
     */
    'ciec'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerFindAllCodesByClient200ResponseDataClientCodes
     */
    'efirma'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerFindAllCodesByClient200ResponseDataClientCodes
     */
    'efirmaRep'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerFindAllCodesByClient200ResponseDataClientCodes
     */
    'csd'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerFindAllCodesByClient200ResponseDataClientCodes
     */
    'imssCertificate'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerFindAllCodesByClient200ResponseDataClientCodes
     */
    'idse'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerFindAllCodesByClient200ResponseDataClientCodes
     */
    'virtualDesktop'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerFindAllCodesByClient200ResponseDataClientCodes
     */
    'sipare'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerFindAllCodesByClient200ResponseDataClientCodes
     */
    'infonavit'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerFindAllCodesByClient200ResponseDataClientCodes
     */
    'isn'?: AccessCode;
    /**
     * 
     * @type {Array<AccessCode>}
     * @memberof ClientCodesControllerFindAllCodesByClient200ResponseDataClientCodes
     */
    'others'?: Array<AccessCode>;
}
/**
 * 
 * @export
 * @interface ClientCodesControllerSaveCodesImss200Response
 */
export interface ClientCodesControllerSaveCodesImss200Response {
    /**
     * 
     * @type {ClientCodesControllerSaveCodesImss200ResponseData}
     * @memberof ClientCodesControllerSaveCodesImss200Response
     */
    'data'?: ClientCodesControllerSaveCodesImss200ResponseData;
}
/**
 * 
 * @export
 * @interface ClientCodesControllerSaveCodesImss200ResponseData
 */
export interface ClientCodesControllerSaveCodesImss200ResponseData {
    /**
     * 
     * @type {ClientCodesControllerSaveCodesImss200ResponseDataClientCodes}
     * @memberof ClientCodesControllerSaveCodesImss200ResponseData
     */
    'clientCodes'?: ClientCodesControllerSaveCodesImss200ResponseDataClientCodes;
    /**
     * 
     * @type {Client}
     * @memberof ClientCodesControllerSaveCodesImss200ResponseData
     */
    'client'?: Client;
}
/**
 * 
 * @export
 * @interface ClientCodesControllerSaveCodesImss200ResponseDataClientCodes
 */
export interface ClientCodesControllerSaveCodesImss200ResponseDataClientCodes {
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerSaveCodesImss200ResponseDataClientCodes
     */
    'imssCertificate'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerSaveCodesImss200ResponseDataClientCodes
     */
    'idse'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerSaveCodesImss200ResponseDataClientCodes
     */
    'virtualDesktop'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerSaveCodesImss200ResponseDataClientCodes
     */
    'sipare'?: AccessCode;
}
/**
 * 
 * @export
 * @interface ClientCodesControllerSaveCodesOthers200Response
 */
export interface ClientCodesControllerSaveCodesOthers200Response {
    /**
     * 
     * @type {ClientCodesControllerSaveCodesOthers200ResponseData}
     * @memberof ClientCodesControllerSaveCodesOthers200Response
     */
    'data'?: ClientCodesControllerSaveCodesOthers200ResponseData;
}
/**
 * 
 * @export
 * @interface ClientCodesControllerSaveCodesOthers200ResponseData
 */
export interface ClientCodesControllerSaveCodesOthers200ResponseData {
    /**
     * 
     * @type {ClientCodesControllerSaveCodesOthers200ResponseDataClientCodes}
     * @memberof ClientCodesControllerSaveCodesOthers200ResponseData
     */
    'clientCodes'?: ClientCodesControllerSaveCodesOthers200ResponseDataClientCodes;
    /**
     * 
     * @type {Client}
     * @memberof ClientCodesControllerSaveCodesOthers200ResponseData
     */
    'client'?: Client;
}
/**
 * 
 * @export
 * @interface ClientCodesControllerSaveCodesOthers200ResponseDataClientCodes
 */
export interface ClientCodesControllerSaveCodesOthers200ResponseDataClientCodes {
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerSaveCodesOthers200ResponseDataClientCodes
     */
    'infonavit'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerSaveCodesOthers200ResponseDataClientCodes
     */
    'isn'?: AccessCode;
    /**
     * 
     * @type {Array<AccessCode>}
     * @memberof ClientCodesControllerSaveCodesOthers200ResponseDataClientCodes
     */
    'others'?: Array<AccessCode>;
}
/**
 * 
 * @export
 * @interface ClientCodesControllerSaveCodesSat200Response
 */
export interface ClientCodesControllerSaveCodesSat200Response {
    /**
     * 
     * @type {ClientCodesControllerSaveCodesSat200ResponseData}
     * @memberof ClientCodesControllerSaveCodesSat200Response
     */
    'data'?: ClientCodesControllerSaveCodesSat200ResponseData;
}
/**
 * 
 * @export
 * @interface ClientCodesControllerSaveCodesSat200ResponseData
 */
export interface ClientCodesControllerSaveCodesSat200ResponseData {
    /**
     * 
     * @type {ClientCodesControllerSaveCodesSat200ResponseDataClientCodes}
     * @memberof ClientCodesControllerSaveCodesSat200ResponseData
     */
    'clientCodes'?: ClientCodesControllerSaveCodesSat200ResponseDataClientCodes;
    /**
     * 
     * @type {Client}
     * @memberof ClientCodesControllerSaveCodesSat200ResponseData
     */
    'client'?: Client;
}
/**
 * 
 * @export
 * @interface ClientCodesControllerSaveCodesSat200ResponseDataClientCodes
 */
export interface ClientCodesControllerSaveCodesSat200ResponseDataClientCodes {
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerSaveCodesSat200ResponseDataClientCodes
     */
    'ciec'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerSaveCodesSat200ResponseDataClientCodes
     */
    'efirma'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerSaveCodesSat200ResponseDataClientCodes
     */
    'efirmaRep'?: AccessCode;
    /**
     * 
     * @type {AccessCode}
     * @memberof ClientCodesControllerSaveCodesSat200ResponseDataClientCodes
     */
    'csd'?: AccessCode;
}
/**
 * 
 * @export
 * @interface ClientDeadlineDto
 */
export interface ClientDeadlineDto {
    /**
     * 
     * @type {number}
     * @memberof ClientDeadlineDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ClientDeadlineDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClientDeadlineDto
     */
    'rfc': string;
    /**
     * 
     * @type {string}
     * @memberof ClientDeadlineDto
     */
    'typePerson': string;
    /**
     * 
     * @type {number}
     * @memberof ClientDeadlineDto
     */
    'digit6': number;
    /**
     * 
     * @type {number}
     * @memberof ClientDeadlineDto
     */
    'aditionalDayClient': number;
    /**
     * 
     * @type {string}
     * @memberof ClientDeadlineDto
     */
    'deadline': string;
}
/**
 * 
 * @export
 * @interface ClientsControllerCreateClient201Response
 */
export interface ClientsControllerCreateClient201Response {
    /**
     * 
     * @type {ClientsControllerCreateClient201ResponseData}
     * @memberof ClientsControllerCreateClient201Response
     */
    'data'?: ClientsControllerCreateClient201ResponseData;
}
/**
 * 
 * @export
 * @interface ClientsControllerCreateClient201ResponseData
 */
export interface ClientsControllerCreateClient201ResponseData {
    /**
     * 
     * @type {Client}
     * @memberof ClientsControllerCreateClient201ResponseData
     */
    'client'?: Client;
}
/**
 * 
 * @export
 * @interface ClientsControllerDueDateClients200Response
 */
export interface ClientsControllerDueDateClients200Response {
    /**
     * 
     * @type {ClientsControllerDueDateClients200ResponseData}
     * @memberof ClientsControllerDueDateClients200Response
     */
    'data'?: ClientsControllerDueDateClients200ResponseData;
}
/**
 * 
 * @export
 * @interface ClientsControllerDueDateClients200ResponseData
 */
export interface ClientsControllerDueDateClients200ResponseData {
    /**
     * 
     * @type {Array<ClientDeadlineDto>}
     * @memberof ClientsControllerDueDateClients200ResponseData
     */
    'clients'?: Array<ClientDeadlineDto>;
    /**
     * 
     * @type {string}
     * @memberof ClientsControllerDueDateClients200ResponseData
     */
    'deadline'?: string;
    /**
     * 
     * @type {Array<Holyday>}
     * @memberof ClientsControllerDueDateClients200ResponseData
     */
    'holydays'?: Array<Holyday>;
}
/**
 * 
 * @export
 * @interface ClientsControllerFindClients200Response
 */
export interface ClientsControllerFindClients200Response {
    /**
     * 
     * @type {ClientsControllerFindClients200ResponseData}
     * @memberof ClientsControllerFindClients200Response
     */
    'data'?: ClientsControllerFindClients200ResponseData;
}
/**
 * 
 * @export
 * @interface ClientsControllerFindClients200ResponseData
 */
export interface ClientsControllerFindClients200ResponseData {
    /**
     * 
     * @type {Array<Client>}
     * @memberof ClientsControllerFindClients200ResponseData
     */
    'clients'?: Array<Client>;
}
/**
 * 
 * @export
 * @interface CreateClientDto
 */
export interface CreateClientDto {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'paternalSurname'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'maternalSurname'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'phone2'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'rfc': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'curp'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'outdoorNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'interiorNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'cologne'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'province'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'legalRepresentativeFullname'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'legalRepresentativeRFC'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'legalRepresentativeCURP'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'observations'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateClientDto
     */
    'regimes': Array<number>;
    /**
     * 
     * @type {Array<ClientActivitiesDto>}
     * @memberof CreateClientDto
     */
    'activities': Array<ClientActivitiesDto>;
}
/**
 * 
 * @export
 * @interface CreateHolydayDto
 */
export interface CreateHolydayDto {
    /**
     * 
     * @type {string}
     * @memberof CreateHolydayDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateHolydayDto
     */
    'date': string;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'paternalSurname'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'maternalSurname'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface Holyday
 */
export interface Holyday {
    /**
     * 
     * @type {number}
     * @memberof Holyday
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Holyday
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Holyday
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof Holyday
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Holyday
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface HolydaysControllerCreateHolyday200Response
 */
export interface HolydaysControllerCreateHolyday200Response {
    /**
     * 
     * @type {HolydaysControllerCreateHolyday200ResponseData}
     * @memberof HolydaysControllerCreateHolyday200Response
     */
    'data'?: HolydaysControllerCreateHolyday200ResponseData;
}
/**
 * 
 * @export
 * @interface HolydaysControllerCreateHolyday200ResponseData
 */
export interface HolydaysControllerCreateHolyday200ResponseData {
    /**
     * 
     * @type {Holyday}
     * @memberof HolydaysControllerCreateHolyday200ResponseData
     */
    'day'?: Holyday;
}
/**
 * 
 * @export
 * @interface HolydaysControllerFindAllHolydays200Response
 */
export interface HolydaysControllerFindAllHolydays200Response {
    /**
     * 
     * @type {HolydaysControllerFindAllHolydays200ResponseData}
     * @memberof HolydaysControllerFindAllHolydays200Response
     */
    'data'?: HolydaysControllerFindAllHolydays200ResponseData;
}
/**
 * 
 * @export
 * @interface HolydaysControllerFindAllHolydays200ResponseData
 */
export interface HolydaysControllerFindAllHolydays200ResponseData {
    /**
     * 
     * @type {Array<Holyday>}
     * @memberof HolydaysControllerFindAllHolydays200ResponseData
     */
    'days'?: Array<Holyday>;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Regime
 */
export interface Regime {
    /**
     * 
     * @type {number}
     * @memberof Regime
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Regime
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Regime
     */
    'key'?: string;
    /**
     * 
     * @type {Array<Client>}
     * @memberof Regime
     */
    'clients'?: Array<Client>;
    /**
     * 
     * @type {string}
     * @memberof Regime
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Regime
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Regime
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface RegimeControllerFindAllRegimes200Response
 */
export interface RegimeControllerFindAllRegimes200Response {
    /**
     * 
     * @type {RegimeControllerFindAllRegimes200ResponseData}
     * @memberof RegimeControllerFindAllRegimes200Response
     */
    'data'?: RegimeControllerFindAllRegimes200ResponseData;
}
/**
 * 
 * @export
 * @interface RegimeControllerFindAllRegimes200ResponseData
 */
export interface RegimeControllerFindAllRegimes200ResponseData {
    /**
     * 
     * @type {Array<Regime>}
     * @memberof RegimeControllerFindAllRegimes200ResponseData
     */
    'regimes'?: Array<Regime>;
}
/**
 * 
 * @export
 * @interface RegimeControllerFindOneRegime200Response
 */
export interface RegimeControllerFindOneRegime200Response {
    /**
     * 
     * @type {RegimeControllerFindOneRegime200ResponseData}
     * @memberof RegimeControllerFindOneRegime200Response
     */
    'data'?: RegimeControllerFindOneRegime200ResponseData;
}
/**
 * 
 * @export
 * @interface RegimeControllerFindOneRegime200ResponseData
 */
export interface RegimeControllerFindOneRegime200ResponseData {
    /**
     * 
     * @type {Regime}
     * @memberof RegimeControllerFindOneRegime200ResponseData
     */
    'regime'?: Regime;
}
/**
 * 
 * @export
 * @interface SaveClientCodesImssDto
 */
export interface SaveClientCodesImssDto {
    /**
     * 
     * @type {SaveClientCodesSatDtoCiec}
     * @memberof SaveClientCodesImssDto
     */
    'imssCertificate'?: SaveClientCodesSatDtoCiec | null;
    /**
     * 
     * @type {SaveClientCodesSatDtoCiec}
     * @memberof SaveClientCodesImssDto
     */
    'idse'?: SaveClientCodesSatDtoCiec | null;
    /**
     * 
     * @type {SaveClientCodesSatDtoCiec}
     * @memberof SaveClientCodesImssDto
     */
    'virtualDesktop'?: SaveClientCodesSatDtoCiec | null;
    /**
     * 
     * @type {SaveClientCodesSatDtoCiec}
     * @memberof SaveClientCodesImssDto
     */
    'sipare'?: SaveClientCodesSatDtoCiec | null;
}
/**
 * 
 * @export
 * @interface SaveClientCodesOthersDto
 */
export interface SaveClientCodesOthersDto {
    /**
     * 
     * @type {SaveClientCodesOthersDtoInfonavit}
     * @memberof SaveClientCodesOthersDto
     */
    'infonavit'?: SaveClientCodesOthersDtoInfonavit | null;
    /**
     * 
     * @type {SaveClientCodesSatDtoCiec}
     * @memberof SaveClientCodesOthersDto
     */
    'isn'?: SaveClientCodesSatDtoCiec | null;
    /**
     * 
     * @type {Array<ClientCodeOthersDto>}
     * @memberof SaveClientCodesOthersDto
     */
    'others'?: Array<ClientCodeOthersDto> | null;
}
/**
 * 
 * @export
 * @interface SaveClientCodesOthersDtoInfonavit
 */
export interface SaveClientCodesOthersDtoInfonavit {
    /**
     * 
     * @type {string}
     * @memberof SaveClientCodesOthersDtoInfonavit
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof SaveClientCodesOthersDtoInfonavit
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof SaveClientCodesOthersDtoInfonavit
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface SaveClientCodesSatDto
 */
export interface SaveClientCodesSatDto {
    /**
     * 
     * @type {SaveClientCodesSatDtoEfirma}
     * @memberof SaveClientCodesSatDto
     */
    'efirma'?: SaveClientCodesSatDtoEfirma | null;
    /**
     * 
     * @type {SaveClientCodesSatDtoEfirma}
     * @memberof SaveClientCodesSatDto
     */
    'efirmaRep'?: SaveClientCodesSatDtoEfirma | null;
    /**
     * 
     * @type {SaveClientCodesSatDtoEfirma}
     * @memberof SaveClientCodesSatDto
     */
    'csd'?: SaveClientCodesSatDtoEfirma | null;
    /**
     * 
     * @type {SaveClientCodesSatDtoCiec}
     * @memberof SaveClientCodesSatDto
     */
    'ciec'?: SaveClientCodesSatDtoCiec | null;
}
/**
 * 
 * @export
 * @interface SaveClientCodesSatDtoCiec
 */
export interface SaveClientCodesSatDtoCiec {
    /**
     * 
     * @type {string}
     * @memberof SaveClientCodesSatDtoCiec
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof SaveClientCodesSatDtoCiec
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface SaveClientCodesSatDtoEfirma
 */
export interface SaveClientCodesSatDtoEfirma {
    /**
     * 
     * @type {string}
     * @memberof SaveClientCodesSatDtoEfirma
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof SaveClientCodesSatDtoEfirma
     */
    'expeditionDate': string;
    /**
     * 
     * @type {string}
     * @memberof SaveClientCodesSatDtoEfirma
     */
    'dueDate': string;
}
/**
 * 
 * @export
 * @interface SoftDeleteClientDto
 */
export interface SoftDeleteClientDto {
    /**
     * 
     * @type {string}
     * @memberof SoftDeleteClientDto
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'paternalSurname': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'maternalSurname'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role': string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'deletedAt': string;
}
/**
 * 
 * @export
 * @interface UsersControllerCreateUser201Response
 */
export interface UsersControllerCreateUser201Response {
    /**
     * 
     * @type {UsersControllerCreateUser201ResponseData}
     * @memberof UsersControllerCreateUser201Response
     */
    'data'?: UsersControllerCreateUser201ResponseData;
}
/**
 * 
 * @export
 * @interface UsersControllerCreateUser201ResponseData
 */
export interface UsersControllerCreateUser201ResponseData {
    /**
     * 
     * @type {User}
     * @memberof UsersControllerCreateUser201ResponseData
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof UsersControllerCreateUser201ResponseData
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface UsersControllerFindAll200Response
 */
export interface UsersControllerFindAll200Response {
    /**
     * 
     * @type {UsersControllerFindAll200ResponseData}
     * @memberof UsersControllerFindAll200Response
     */
    'data'?: UsersControllerFindAll200ResponseData;
}
/**
 * 
 * @export
 * @interface UsersControllerFindAll200ResponseData
 */
export interface UsersControllerFindAll200ResponseData {
    /**
     * 
     * @type {Array<User>}
     * @memberof UsersControllerFindAll200ResponseData
     */
    'users'?: Array<User>;
}
/**
 * 
 * @export
 * @interface UsersControllerFindAll400Response
 */
export interface UsersControllerFindAll400Response {
    /**
     * 
     * @type {number}
     * @memberof UsersControllerFindAll400Response
     */
    'statusCode'?: number;
    /**
     * 
     * @type {UsersControllerFindAll400ResponseMessage}
     * @memberof UsersControllerFindAll400Response
     */
    'message'?: UsersControllerFindAll400ResponseMessage;
    /**
     * 
     * @type {string}
     * @memberof UsersControllerFindAll400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UsersControllerFindAll400ResponseMessage
 */
export interface UsersControllerFindAll400ResponseMessage {
}
/**
 * 
 * @export
 * @interface UsersControllerFindOne200Response
 */
export interface UsersControllerFindOne200Response {
    /**
     * 
     * @type {UsersControllerFindOne200ResponseData}
     * @memberof UsersControllerFindOne200Response
     */
    'data'?: UsersControllerFindOne200ResponseData;
}
/**
 * 
 * @export
 * @interface UsersControllerFindOne200ResponseData
 */
export interface UsersControllerFindOne200ResponseData {
    /**
     * 
     * @type {User}
     * @memberof UsersControllerFindOne200ResponseData
     */
    'user'?: User;
}

/**
 * AccessCodesApi - axios parameter creator
 * @export
 */
export const AccessCodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [clientId] 
         * @param {'SAT' | 'IMSS' | 'OTRA'} [category] 
         * @param {'CIEC' | 'E.FIRMA' | 'E.FIRMA REP LEGAL' | 'CSD' | 'CERTIFICADO IMSS' | 'IDSE' | 'ESCRITORIO VIRTUAL IMSS' | 'SIPARE' | 'INFONAVIT' | 'ISN'} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessCodesControllerFindAllCodes: async (clientId?: number, category?: 'SAT' | 'IMSS' | 'OTRA', name?: 'CIEC' | 'E.FIRMA' | 'E.FIRMA REP LEGAL' | 'CSD' | 'CERTIFICADO IMSS' | 'IDSE' | 'ESCRITORIO VIRTUAL IMSS' | 'SIPARE' | 'INFONAVIT' | 'ISN', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessCodesControllerFindCodeNames: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-codes/names`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} codeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessCodesControllerFindOneCode: async (codeId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'codeId' is not null or undefined
            assertParamExists('accessCodesControllerFindOneCode', 'codeId', codeId)
            const localVarPath = `/access-codes/{codeId}`
                .replace(`{${"codeId"}}`, encodeURIComponent(String(codeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} codeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessCodesControllerRemoveCode: async (codeId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'codeId' is not null or undefined
            assertParamExists('accessCodesControllerRemoveCode', 'codeId', codeId)
            const localVarPath = `/access-codes/{codeId}`
                .replace(`{${"codeId"}}`, encodeURIComponent(String(codeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} codeId 
         * @param {AccessCodeUpdateDto} accessCodeUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessCodesControllerUpdateCode: async (codeId: number, accessCodeUpdateDto: AccessCodeUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'codeId' is not null or undefined
            assertParamExists('accessCodesControllerUpdateCode', 'codeId', codeId)
            // verify required parameter 'accessCodeUpdateDto' is not null or undefined
            assertParamExists('accessCodesControllerUpdateCode', 'accessCodeUpdateDto', accessCodeUpdateDto)
            const localVarPath = `/access-codes/{codeId}`
                .replace(`{${"codeId"}}`, encodeURIComponent(String(codeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessCodeUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessCodesApi - functional programming interface
 * @export
 */
export const AccessCodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessCodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [clientId] 
         * @param {'SAT' | 'IMSS' | 'OTRA'} [category] 
         * @param {'CIEC' | 'E.FIRMA' | 'E.FIRMA REP LEGAL' | 'CSD' | 'CERTIFICADO IMSS' | 'IDSE' | 'ESCRITORIO VIRTUAL IMSS' | 'SIPARE' | 'INFONAVIT' | 'ISN'} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessCodesControllerFindAllCodes(clientId?: number, category?: 'SAT' | 'IMSS' | 'OTRA', name?: 'CIEC' | 'E.FIRMA' | 'E.FIRMA REP LEGAL' | 'CSD' | 'CERTIFICADO IMSS' | 'IDSE' | 'ESCRITORIO VIRTUAL IMSS' | 'SIPARE' | 'INFONAVIT' | 'ISN', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCodesControllerFindAllCodes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessCodesControllerFindAllCodes(clientId, category, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessCodesControllerFindCodeNames(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCodesControllerFindCodeNames200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessCodesControllerFindCodeNames(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} codeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessCodesControllerFindOneCode(codeId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCodesControllerFindOneCode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessCodesControllerFindOneCode(codeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} codeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessCodesControllerRemoveCode(codeId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCodesControllerFindOneCode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessCodesControllerRemoveCode(codeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} codeId 
         * @param {AccessCodeUpdateDto} accessCodeUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessCodesControllerUpdateCode(codeId: number, accessCodeUpdateDto: AccessCodeUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCodesControllerFindOneCode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessCodesControllerUpdateCode(codeId, accessCodeUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessCodesApi - factory interface
 * @export
 */
export const AccessCodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessCodesApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [clientId] 
         * @param {'SAT' | 'IMSS' | 'OTRA'} [category] 
         * @param {'CIEC' | 'E.FIRMA' | 'E.FIRMA REP LEGAL' | 'CSD' | 'CERTIFICADO IMSS' | 'IDSE' | 'ESCRITORIO VIRTUAL IMSS' | 'SIPARE' | 'INFONAVIT' | 'ISN'} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessCodesControllerFindAllCodes(clientId?: number, category?: 'SAT' | 'IMSS' | 'OTRA', name?: 'CIEC' | 'E.FIRMA' | 'E.FIRMA REP LEGAL' | 'CSD' | 'CERTIFICADO IMSS' | 'IDSE' | 'ESCRITORIO VIRTUAL IMSS' | 'SIPARE' | 'INFONAVIT' | 'ISN', options?: any): AxiosPromise<AccessCodesControllerFindAllCodes200Response> {
            return localVarFp.accessCodesControllerFindAllCodes(clientId, category, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessCodesControllerFindCodeNames(options?: any): AxiosPromise<AccessCodesControllerFindCodeNames200Response> {
            return localVarFp.accessCodesControllerFindCodeNames(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} codeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessCodesControllerFindOneCode(codeId: number, options?: any): AxiosPromise<AccessCodesControllerFindOneCode200Response> {
            return localVarFp.accessCodesControllerFindOneCode(codeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} codeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessCodesControllerRemoveCode(codeId: number, options?: any): AxiosPromise<AccessCodesControllerFindOneCode200Response> {
            return localVarFp.accessCodesControllerRemoveCode(codeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} codeId 
         * @param {AccessCodeUpdateDto} accessCodeUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessCodesControllerUpdateCode(codeId: number, accessCodeUpdateDto: AccessCodeUpdateDto, options?: any): AxiosPromise<AccessCodesControllerFindOneCode200Response> {
            return localVarFp.accessCodesControllerUpdateCode(codeId, accessCodeUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessCodesApi - object-oriented interface
 * @export
 * @class AccessCodesApi
 * @extends {BaseAPI}
 */
export class AccessCodesApi extends BaseAPI {
    /**
     * 
     * @param {number} [clientId] 
     * @param {'SAT' | 'IMSS' | 'OTRA'} [category] 
     * @param {'CIEC' | 'E.FIRMA' | 'E.FIRMA REP LEGAL' | 'CSD' | 'CERTIFICADO IMSS' | 'IDSE' | 'ESCRITORIO VIRTUAL IMSS' | 'SIPARE' | 'INFONAVIT' | 'ISN'} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessCodesApi
     */
    public accessCodesControllerFindAllCodes(clientId?: number, category?: 'SAT' | 'IMSS' | 'OTRA', name?: 'CIEC' | 'E.FIRMA' | 'E.FIRMA REP LEGAL' | 'CSD' | 'CERTIFICADO IMSS' | 'IDSE' | 'ESCRITORIO VIRTUAL IMSS' | 'SIPARE' | 'INFONAVIT' | 'ISN', options?: AxiosRequestConfig) {
        return AccessCodesApiFp(this.configuration).accessCodesControllerFindAllCodes(clientId, category, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessCodesApi
     */
    public accessCodesControllerFindCodeNames(options?: AxiosRequestConfig) {
        return AccessCodesApiFp(this.configuration).accessCodesControllerFindCodeNames(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} codeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessCodesApi
     */
    public accessCodesControllerFindOneCode(codeId: number, options?: AxiosRequestConfig) {
        return AccessCodesApiFp(this.configuration).accessCodesControllerFindOneCode(codeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} codeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessCodesApi
     */
    public accessCodesControllerRemoveCode(codeId: number, options?: AxiosRequestConfig) {
        return AccessCodesApiFp(this.configuration).accessCodesControllerRemoveCode(codeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} codeId 
     * @param {AccessCodeUpdateDto} accessCodeUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessCodesApi
     */
    public accessCodesControllerUpdateCode(codeId: number, accessCodeUpdateDto: AccessCodeUpdateDto, options?: AxiosRequestConfig) {
        return AccessCodesApiFp(this.configuration).accessCodesControllerUpdateCode(codeId, accessCodeUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * endpoint para probar que cualquier rol puede acceder a el
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerBothRoles: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * endpoint para obtener los datos del usuario en sesion
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * endpoint para autenticacion de usuario, se espera recibir un email y un password en el body de tipo json
         * @summary 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginDto: LoginDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * endpoint test permitido solo a usuarios con rol administrador
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerOnlyAdmin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * endpoint test permitido solo a usuarios con rol operativo
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerOnlyOperativo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/operational`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * endpoint para probar que cualquier rol puede acceder a el
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerBothRoles(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerBothRoles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * endpoint para obtener los datos del usuario en sesion
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetProfile(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetProfile(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * endpoint para autenticacion de usuario, se espera recibir un email y un password en el body de tipo json
         * @summary 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginDto: LoginDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLogin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * endpoint test permitido solo a usuarios con rol administrador
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerOnlyAdmin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerOnlyAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * endpoint test permitido solo a usuarios con rol operativo
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerOnlyOperativo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerOnlyOperativo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * endpoint para probar que cualquier rol puede acceder a el
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerBothRoles(options?: any): AxiosPromise<void> {
            return localVarFp.authControllerBothRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * endpoint para obtener los datos del usuario en sesion
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile(options?: any): AxiosPromise<UsersControllerFindOne200Response> {
            return localVarFp.authControllerGetProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * endpoint para autenticacion de usuario, se espera recibir un email y un password en el body de tipo json
         * @summary 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginDto: LoginDto, options?: any): AxiosPromise<AuthControllerLogin200Response> {
            return localVarFp.authControllerLogin(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * endpoint test permitido solo a usuarios con rol administrador
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerOnlyAdmin(options?: any): AxiosPromise<void> {
            return localVarFp.authControllerOnlyAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * endpoint test permitido solo a usuarios con rol operativo
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerOnlyOperativo(options?: any): AxiosPromise<void> {
            return localVarFp.authControllerOnlyOperativo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * endpoint para probar que cualquier rol puede acceder a el
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerBothRoles(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerBothRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * endpoint para obtener los datos del usuario en sesion
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetProfile(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * endpoint para autenticacion de usuario, se espera recibir un email y un password en el body de tipo json
     * @summary 
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogin(loginDto: LoginDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogin(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * endpoint test permitido solo a usuarios con rol administrador
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerOnlyAdmin(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerOnlyAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * endpoint test permitido solo a usuarios con rol operativo
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerOnlyOperativo(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerOnlyOperativo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientesApi - axios parameter creator
 * @export
 */
export const ClientesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Crea un cliente con sus respectivos datos y devuelve el cliente creado
         * @summary 
         * @param {CreateClientDto} createClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerCreateClient: async (createClientDto: CreateClientDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createClientDto' is not null or undefined
            assertParamExists('clientsControllerCreateClient', 'createClientDto', createClientDto)
            const localVarPath = `/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createClientDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * listado de clientes con fechas de impuestos aproximadas
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerDueDateClients: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/clients/due-date`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene una lista de clientes registrados en el sistema, con informacion basica
         * @summary 
         * @param {0 | 1} [inactive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerFindClients: async (inactive?: 0 | 1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (inactive !== undefined) {
                localVarQueryParameter['inactive'] = inactive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * obtener todos los datos del un cliente en particular, agrego una bandera query para obtener un cliente sofdelete
         * @summary 
         * @param {number} clientId 
         * @param {0 | 1} [inactive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerFindOneClient: async (clientId: number, inactive?: 0 | 1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('clientsControllerFindOneClient', 'clientId', clientId)
            const localVarPath = `/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (inactive !== undefined) {
                localVarQueryParameter['inactive'] = inactive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Elimina un cliente por id por completo de la base de datos
         * @summary 
         * @param {number} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerForceRemoveClient: async (clientId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('clientsControllerForceRemoveClient', 'clientId', clientId)
            const localVarPath = `/clients/{clientId}/destroy`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * reestablece un cliente que fue eliminado temporalmente
         * @summary 
         * @param {number} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerRestoreClient: async (clientId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('clientsControllerRestoreClient', 'clientId', clientId)
            const localVarPath = `/clients/{clientId}/restore`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Elimina un cliente por id, se conservan sus datos (borrado logico)
         * @summary 
         * @param {number} clientId 
         * @param {SoftDeleteClientDto} softDeleteClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerSoftRemoveClient: async (clientId: number, softDeleteClientDto: SoftDeleteClientDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('clientsControllerSoftRemoveClient', 'clientId', clientId)
            // verify required parameter 'softDeleteClientDto' is not null or undefined
            assertParamExists('clientsControllerSoftRemoveClient', 'softDeleteClientDto', softDeleteClientDto)
            const localVarPath = `/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(softDeleteClientDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Actualiza los datos de un cliente
         * @summary 
         * @param {number} clientId 
         * @param {CreateClientDto} createClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerUpdateClient: async (clientId: number, createClientDto: CreateClientDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('clientsControllerUpdateClient', 'clientId', clientId)
            // verify required parameter 'createClientDto' is not null or undefined
            assertParamExists('clientsControllerUpdateClient', 'createClientDto', createClientDto)
            const localVarPath = `/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createClientDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientesApi - functional programming interface
 * @export
 */
export const ClientesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientesApiAxiosParamCreator(configuration)
    return {
        /**
         * Crea un cliente con sus respectivos datos y devuelve el cliente creado
         * @summary 
         * @param {CreateClientDto} createClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsControllerCreateClient(createClientDto: CreateClientDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientsControllerCreateClient201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientsControllerCreateClient(createClientDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * listado de clientes con fechas de impuestos aproximadas
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsControllerDueDateClients(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientsControllerDueDateClients200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientsControllerDueDateClients(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Obtiene una lista de clientes registrados en el sistema, con informacion basica
         * @summary 
         * @param {0 | 1} [inactive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsControllerFindClients(inactive?: 0 | 1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientsControllerFindClients200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientsControllerFindClients(inactive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * obtener todos los datos del un cliente en particular, agrego una bandera query para obtener un cliente sofdelete
         * @summary 
         * @param {number} clientId 
         * @param {0 | 1} [inactive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsControllerFindOneClient(clientId: number, inactive?: 0 | 1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientsControllerCreateClient201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientsControllerFindOneClient(clientId, inactive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Elimina un cliente por id por completo de la base de datos
         * @summary 
         * @param {number} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsControllerForceRemoveClient(clientId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientsControllerCreateClient201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientsControllerForceRemoveClient(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * reestablece un cliente que fue eliminado temporalmente
         * @summary 
         * @param {number} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsControllerRestoreClient(clientId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientsControllerCreateClient201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientsControllerRestoreClient(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Elimina un cliente por id, se conservan sus datos (borrado logico)
         * @summary 
         * @param {number} clientId 
         * @param {SoftDeleteClientDto} softDeleteClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsControllerSoftRemoveClient(clientId: number, softDeleteClientDto: SoftDeleteClientDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientsControllerCreateClient201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientsControllerSoftRemoveClient(clientId, softDeleteClientDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Actualiza los datos de un cliente
         * @summary 
         * @param {number} clientId 
         * @param {CreateClientDto} createClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsControllerUpdateClient(clientId: number, createClientDto: CreateClientDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientsControllerCreateClient201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientsControllerUpdateClient(clientId, createClientDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientesApi - factory interface
 * @export
 */
export const ClientesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientesApiFp(configuration)
    return {
        /**
         * Crea un cliente con sus respectivos datos y devuelve el cliente creado
         * @summary 
         * @param {CreateClientDto} createClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerCreateClient(createClientDto: CreateClientDto, options?: any): AxiosPromise<ClientsControllerCreateClient201Response> {
            return localVarFp.clientsControllerCreateClient(createClientDto, options).then((request) => request(axios, basePath));
        },
        /**
         * listado de clientes con fechas de impuestos aproximadas
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerDueDateClients(options?: any): AxiosPromise<ClientsControllerDueDateClients200Response> {
            return localVarFp.clientsControllerDueDateClients(options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene una lista de clientes registrados en el sistema, con informacion basica
         * @summary 
         * @param {0 | 1} [inactive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerFindClients(inactive?: 0 | 1, options?: any): AxiosPromise<ClientsControllerFindClients200Response> {
            return localVarFp.clientsControllerFindClients(inactive, options).then((request) => request(axios, basePath));
        },
        /**
         * obtener todos los datos del un cliente en particular, agrego una bandera query para obtener un cliente sofdelete
         * @summary 
         * @param {number} clientId 
         * @param {0 | 1} [inactive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerFindOneClient(clientId: number, inactive?: 0 | 1, options?: any): AxiosPromise<ClientsControllerCreateClient201Response> {
            return localVarFp.clientsControllerFindOneClient(clientId, inactive, options).then((request) => request(axios, basePath));
        },
        /**
         * Elimina un cliente por id por completo de la base de datos
         * @summary 
         * @param {number} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerForceRemoveClient(clientId: number, options?: any): AxiosPromise<ClientsControllerCreateClient201Response> {
            return localVarFp.clientsControllerForceRemoveClient(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * reestablece un cliente que fue eliminado temporalmente
         * @summary 
         * @param {number} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerRestoreClient(clientId: number, options?: any): AxiosPromise<ClientsControllerCreateClient201Response> {
            return localVarFp.clientsControllerRestoreClient(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Elimina un cliente por id, se conservan sus datos (borrado logico)
         * @summary 
         * @param {number} clientId 
         * @param {SoftDeleteClientDto} softDeleteClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerSoftRemoveClient(clientId: number, softDeleteClientDto: SoftDeleteClientDto, options?: any): AxiosPromise<ClientsControllerCreateClient201Response> {
            return localVarFp.clientsControllerSoftRemoveClient(clientId, softDeleteClientDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Actualiza los datos de un cliente
         * @summary 
         * @param {number} clientId 
         * @param {CreateClientDto} createClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsControllerUpdateClient(clientId: number, createClientDto: CreateClientDto, options?: any): AxiosPromise<ClientsControllerCreateClient201Response> {
            return localVarFp.clientsControllerUpdateClient(clientId, createClientDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientesApi - object-oriented interface
 * @export
 * @class ClientesApi
 * @extends {BaseAPI}
 */
export class ClientesApi extends BaseAPI {
    /**
     * Crea un cliente con sus respectivos datos y devuelve el cliente creado
     * @summary 
     * @param {CreateClientDto} createClientDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientesApi
     */
    public clientsControllerCreateClient(createClientDto: CreateClientDto, options?: AxiosRequestConfig) {
        return ClientesApiFp(this.configuration).clientsControllerCreateClient(createClientDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * listado de clientes con fechas de impuestos aproximadas
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientesApi
     */
    public clientsControllerDueDateClients(options?: AxiosRequestConfig) {
        return ClientesApiFp(this.configuration).clientsControllerDueDateClients(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene una lista de clientes registrados en el sistema, con informacion basica
     * @summary 
     * @param {0 | 1} [inactive] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientesApi
     */
    public clientsControllerFindClients(inactive?: 0 | 1, options?: AxiosRequestConfig) {
        return ClientesApiFp(this.configuration).clientsControllerFindClients(inactive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * obtener todos los datos del un cliente en particular, agrego una bandera query para obtener un cliente sofdelete
     * @summary 
     * @param {number} clientId 
     * @param {0 | 1} [inactive] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientesApi
     */
    public clientsControllerFindOneClient(clientId: number, inactive?: 0 | 1, options?: AxiosRequestConfig) {
        return ClientesApiFp(this.configuration).clientsControllerFindOneClient(clientId, inactive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Elimina un cliente por id por completo de la base de datos
     * @summary 
     * @param {number} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientesApi
     */
    public clientsControllerForceRemoveClient(clientId: number, options?: AxiosRequestConfig) {
        return ClientesApiFp(this.configuration).clientsControllerForceRemoveClient(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * reestablece un cliente que fue eliminado temporalmente
     * @summary 
     * @param {number} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientesApi
     */
    public clientsControllerRestoreClient(clientId: number, options?: AxiosRequestConfig) {
        return ClientesApiFp(this.configuration).clientsControllerRestoreClient(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Elimina un cliente por id, se conservan sus datos (borrado logico)
     * @summary 
     * @param {number} clientId 
     * @param {SoftDeleteClientDto} softDeleteClientDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientesApi
     */
    public clientsControllerSoftRemoveClient(clientId: number, softDeleteClientDto: SoftDeleteClientDto, options?: AxiosRequestConfig) {
        return ClientesApiFp(this.configuration).clientsControllerSoftRemoveClient(clientId, softDeleteClientDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Actualiza los datos de un cliente
     * @summary 
     * @param {number} clientId 
     * @param {CreateClientDto} createClientDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientesApi
     */
    public clientsControllerUpdateClient(clientId: number, createClientDto: CreateClientDto, options?: AxiosRequestConfig) {
        return ClientesApiFp(this.configuration).clientsControllerUpdateClient(clientId, createClientDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CodigosDeClienteApi - axios parameter creator
 * @export
 */
export const CodigosDeClienteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} clientId 
         * @param {'SAT' | 'IMSS' | 'OTRA'} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCodesControllerFindAllCodesByClient: async (clientId: number, category?: 'SAT' | 'IMSS' | 'OTRA', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('clientCodesControllerFindAllCodesByClient', 'clientId', clientId)
            const localVarPath = `/clients/{clientId}/codes`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} clientId 
         * @param {SaveClientCodesImssDto} saveClientCodesImssDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCodesControllerSaveCodesImss: async (clientId: number, saveClientCodesImssDto: SaveClientCodesImssDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('clientCodesControllerSaveCodesImss', 'clientId', clientId)
            // verify required parameter 'saveClientCodesImssDto' is not null or undefined
            assertParamExists('clientCodesControllerSaveCodesImss', 'saveClientCodesImssDto', saveClientCodesImssDto)
            const localVarPath = `/clients/{clientId}/codes/imss`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveClientCodesImssDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} clientId 
         * @param {SaveClientCodesOthersDto} saveClientCodesOthersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCodesControllerSaveCodesOthers: async (clientId: number, saveClientCodesOthersDto: SaveClientCodesOthersDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('clientCodesControllerSaveCodesOthers', 'clientId', clientId)
            // verify required parameter 'saveClientCodesOthersDto' is not null or undefined
            assertParamExists('clientCodesControllerSaveCodesOthers', 'saveClientCodesOthersDto', saveClientCodesOthersDto)
            const localVarPath = `/clients/{clientId}/codes/others`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveClientCodesOthersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} clientId 
         * @param {SaveClientCodesSatDto} saveClientCodesSatDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCodesControllerSaveCodesSat: async (clientId: number, saveClientCodesSatDto: SaveClientCodesSatDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('clientCodesControllerSaveCodesSat', 'clientId', clientId)
            // verify required parameter 'saveClientCodesSatDto' is not null or undefined
            assertParamExists('clientCodesControllerSaveCodesSat', 'saveClientCodesSatDto', saveClientCodesSatDto)
            const localVarPath = `/clients/{clientId}/codes/sat`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveClientCodesSatDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CodigosDeClienteApi - functional programming interface
 * @export
 */
export const CodigosDeClienteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CodigosDeClienteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} clientId 
         * @param {'SAT' | 'IMSS' | 'OTRA'} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCodesControllerFindAllCodesByClient(clientId: number, category?: 'SAT' | 'IMSS' | 'OTRA', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientCodesControllerFindAllCodesByClient200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientCodesControllerFindAllCodesByClient(clientId, category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} clientId 
         * @param {SaveClientCodesImssDto} saveClientCodesImssDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCodesControllerSaveCodesImss(clientId: number, saveClientCodesImssDto: SaveClientCodesImssDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientCodesControllerSaveCodesImss200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientCodesControllerSaveCodesImss(clientId, saveClientCodesImssDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} clientId 
         * @param {SaveClientCodesOthersDto} saveClientCodesOthersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCodesControllerSaveCodesOthers(clientId: number, saveClientCodesOthersDto: SaveClientCodesOthersDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientCodesControllerSaveCodesOthers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientCodesControllerSaveCodesOthers(clientId, saveClientCodesOthersDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} clientId 
         * @param {SaveClientCodesSatDto} saveClientCodesSatDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCodesControllerSaveCodesSat(clientId: number, saveClientCodesSatDto: SaveClientCodesSatDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientCodesControllerSaveCodesSat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientCodesControllerSaveCodesSat(clientId, saveClientCodesSatDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CodigosDeClienteApi - factory interface
 * @export
 */
export const CodigosDeClienteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CodigosDeClienteApiFp(configuration)
    return {
        /**
         * 
         * @param {number} clientId 
         * @param {'SAT' | 'IMSS' | 'OTRA'} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCodesControllerFindAllCodesByClient(clientId: number, category?: 'SAT' | 'IMSS' | 'OTRA', options?: any): AxiosPromise<ClientCodesControllerFindAllCodesByClient200Response> {
            return localVarFp.clientCodesControllerFindAllCodesByClient(clientId, category, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} clientId 
         * @param {SaveClientCodesImssDto} saveClientCodesImssDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCodesControllerSaveCodesImss(clientId: number, saveClientCodesImssDto: SaveClientCodesImssDto, options?: any): AxiosPromise<ClientCodesControllerSaveCodesImss200Response> {
            return localVarFp.clientCodesControllerSaveCodesImss(clientId, saveClientCodesImssDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} clientId 
         * @param {SaveClientCodesOthersDto} saveClientCodesOthersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCodesControllerSaveCodesOthers(clientId: number, saveClientCodesOthersDto: SaveClientCodesOthersDto, options?: any): AxiosPromise<ClientCodesControllerSaveCodesOthers200Response> {
            return localVarFp.clientCodesControllerSaveCodesOthers(clientId, saveClientCodesOthersDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} clientId 
         * @param {SaveClientCodesSatDto} saveClientCodesSatDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCodesControllerSaveCodesSat(clientId: number, saveClientCodesSatDto: SaveClientCodesSatDto, options?: any): AxiosPromise<ClientCodesControllerSaveCodesSat200Response> {
            return localVarFp.clientCodesControllerSaveCodesSat(clientId, saveClientCodesSatDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CodigosDeClienteApi - object-oriented interface
 * @export
 * @class CodigosDeClienteApi
 * @extends {BaseAPI}
 */
export class CodigosDeClienteApi extends BaseAPI {
    /**
     * 
     * @param {number} clientId 
     * @param {'SAT' | 'IMSS' | 'OTRA'} [category] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodigosDeClienteApi
     */
    public clientCodesControllerFindAllCodesByClient(clientId: number, category?: 'SAT' | 'IMSS' | 'OTRA', options?: AxiosRequestConfig) {
        return CodigosDeClienteApiFp(this.configuration).clientCodesControllerFindAllCodesByClient(clientId, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} clientId 
     * @param {SaveClientCodesImssDto} saveClientCodesImssDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodigosDeClienteApi
     */
    public clientCodesControllerSaveCodesImss(clientId: number, saveClientCodesImssDto: SaveClientCodesImssDto, options?: AxiosRequestConfig) {
        return CodigosDeClienteApiFp(this.configuration).clientCodesControllerSaveCodesImss(clientId, saveClientCodesImssDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} clientId 
     * @param {SaveClientCodesOthersDto} saveClientCodesOthersDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodigosDeClienteApi
     */
    public clientCodesControllerSaveCodesOthers(clientId: number, saveClientCodesOthersDto: SaveClientCodesOthersDto, options?: AxiosRequestConfig) {
        return CodigosDeClienteApiFp(this.configuration).clientCodesControllerSaveCodesOthers(clientId, saveClientCodesOthersDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} clientId 
     * @param {SaveClientCodesSatDto} saveClientCodesSatDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodigosDeClienteApi
     */
    public clientCodesControllerSaveCodesSat(clientId: number, saveClientCodesSatDto: SaveClientCodesSatDto, options?: AxiosRequestConfig) {
        return CodigosDeClienteApiFp(this.configuration).clientCodesControllerSaveCodesSat(clientId, saveClientCodesSatDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HolydaysApi - axios parameter creator
 * @export
 */
export const HolydaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateHolydayDto} createHolydayDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holydaysControllerCreateHolyday: async (createHolydayDto: CreateHolydayDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createHolydayDto' is not null or undefined
            assertParamExists('holydaysControllerCreateHolyday', 'createHolydayDto', createHolydayDto)
            const localVarPath = `/holydays`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createHolydayDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holydaysControllerFindAllHolydays: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/holydays`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holydaysControllerFindAllHolydaysByYear: async (year: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'year' is not null or undefined
            assertParamExists('holydaysControllerFindAllHolydaysByYear', 'year', year)
            const localVarPath = `/holydays/year/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} dayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holydaysControllerFindOneHolyday: async (dayId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dayId' is not null or undefined
            assertParamExists('holydaysControllerFindOneHolyday', 'dayId', dayId)
            const localVarPath = `/holydays/{dayId}`
                .replace(`{${"dayId"}}`, encodeURIComponent(String(dayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} dayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holydaysControllerRemove: async (dayId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dayId' is not null or undefined
            assertParamExists('holydaysControllerRemove', 'dayId', dayId)
            const localVarPath = `/holydays/{dayId}`
                .replace(`{${"dayId"}}`, encodeURIComponent(String(dayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} dayId 
         * @param {CreateHolydayDto} createHolydayDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holydaysControllerUpdate: async (dayId: number, createHolydayDto: CreateHolydayDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dayId' is not null or undefined
            assertParamExists('holydaysControllerUpdate', 'dayId', dayId)
            // verify required parameter 'createHolydayDto' is not null or undefined
            assertParamExists('holydaysControllerUpdate', 'createHolydayDto', createHolydayDto)
            const localVarPath = `/holydays/{dayId}`
                .replace(`{${"dayId"}}`, encodeURIComponent(String(dayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createHolydayDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HolydaysApi - functional programming interface
 * @export
 */
export const HolydaysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HolydaysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateHolydayDto} createHolydayDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async holydaysControllerCreateHolyday(createHolydayDto: CreateHolydayDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HolydaysControllerCreateHolyday200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.holydaysControllerCreateHolyday(createHolydayDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async holydaysControllerFindAllHolydays(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HolydaysControllerFindAllHolydays200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.holydaysControllerFindAllHolydays(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async holydaysControllerFindAllHolydaysByYear(year: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HolydaysControllerFindAllHolydays200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.holydaysControllerFindAllHolydaysByYear(year, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} dayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async holydaysControllerFindOneHolyday(dayId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HolydaysControllerCreateHolyday200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.holydaysControllerFindOneHolyday(dayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} dayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async holydaysControllerRemove(dayId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HolydaysControllerCreateHolyday200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.holydaysControllerRemove(dayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} dayId 
         * @param {CreateHolydayDto} createHolydayDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async holydaysControllerUpdate(dayId: number, createHolydayDto: CreateHolydayDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HolydaysControllerCreateHolyday200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.holydaysControllerUpdate(dayId, createHolydayDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HolydaysApi - factory interface
 * @export
 */
export const HolydaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HolydaysApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateHolydayDto} createHolydayDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holydaysControllerCreateHolyday(createHolydayDto: CreateHolydayDto, options?: any): AxiosPromise<HolydaysControllerCreateHolyday200Response> {
            return localVarFp.holydaysControllerCreateHolyday(createHolydayDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holydaysControllerFindAllHolydays(options?: any): AxiosPromise<HolydaysControllerFindAllHolydays200Response> {
            return localVarFp.holydaysControllerFindAllHolydays(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holydaysControllerFindAllHolydaysByYear(year: number, options?: any): AxiosPromise<HolydaysControllerFindAllHolydays200Response> {
            return localVarFp.holydaysControllerFindAllHolydaysByYear(year, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} dayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holydaysControllerFindOneHolyday(dayId: number, options?: any): AxiosPromise<HolydaysControllerCreateHolyday200Response> {
            return localVarFp.holydaysControllerFindOneHolyday(dayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} dayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holydaysControllerRemove(dayId: number, options?: any): AxiosPromise<HolydaysControllerCreateHolyday200Response> {
            return localVarFp.holydaysControllerRemove(dayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} dayId 
         * @param {CreateHolydayDto} createHolydayDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holydaysControllerUpdate(dayId: number, createHolydayDto: CreateHolydayDto, options?: any): AxiosPromise<HolydaysControllerCreateHolyday200Response> {
            return localVarFp.holydaysControllerUpdate(dayId, createHolydayDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HolydaysApi - object-oriented interface
 * @export
 * @class HolydaysApi
 * @extends {BaseAPI}
 */
export class HolydaysApi extends BaseAPI {
    /**
     * 
     * @param {CreateHolydayDto} createHolydayDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HolydaysApi
     */
    public holydaysControllerCreateHolyday(createHolydayDto: CreateHolydayDto, options?: AxiosRequestConfig) {
        return HolydaysApiFp(this.configuration).holydaysControllerCreateHolyday(createHolydayDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HolydaysApi
     */
    public holydaysControllerFindAllHolydays(options?: AxiosRequestConfig) {
        return HolydaysApiFp(this.configuration).holydaysControllerFindAllHolydays(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} year 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HolydaysApi
     */
    public holydaysControllerFindAllHolydaysByYear(year: number, options?: AxiosRequestConfig) {
        return HolydaysApiFp(this.configuration).holydaysControllerFindAllHolydaysByYear(year, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} dayId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HolydaysApi
     */
    public holydaysControllerFindOneHolyday(dayId: number, options?: AxiosRequestConfig) {
        return HolydaysApiFp(this.configuration).holydaysControllerFindOneHolyday(dayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} dayId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HolydaysApi
     */
    public holydaysControllerRemove(dayId: number, options?: AxiosRequestConfig) {
        return HolydaysApiFp(this.configuration).holydaysControllerRemove(dayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} dayId 
     * @param {CreateHolydayDto} createHolydayDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HolydaysApi
     */
    public holydaysControllerUpdate(dayId: number, createHolydayDto: CreateHolydayDto, options?: AxiosRequestConfig) {
        return HolydaysApiFp(this.configuration).holydaysControllerUpdate(dayId, createHolydayDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegimenFiscalApi - axios parameter creator
 * @export
 */
export const RegimenFiscalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Obtener un listado de los regimen fiscales que existen en base de datos
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regimeControllerFindAllRegimes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/regimes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} regimeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regimeControllerFindOneRegime: async (regimeId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regimeId' is not null or undefined
            assertParamExists('regimeControllerFindOneRegime', 'regimeId', regimeId)
            const localVarPath = `/regimes/{regimeId}`
                .replace(`{${"regimeId"}}`, encodeURIComponent(String(regimeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegimenFiscalApi - functional programming interface
 * @export
 */
export const RegimenFiscalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegimenFiscalApiAxiosParamCreator(configuration)
    return {
        /**
         * Obtener un listado de los regimen fiscales que existen en base de datos
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regimeControllerFindAllRegimes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegimeControllerFindAllRegimes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regimeControllerFindAllRegimes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} regimeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regimeControllerFindOneRegime(regimeId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegimeControllerFindOneRegime200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regimeControllerFindOneRegime(regimeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegimenFiscalApi - factory interface
 * @export
 */
export const RegimenFiscalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegimenFiscalApiFp(configuration)
    return {
        /**
         * Obtener un listado de los regimen fiscales que existen en base de datos
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regimeControllerFindAllRegimes(options?: any): AxiosPromise<RegimeControllerFindAllRegimes200Response> {
            return localVarFp.regimeControllerFindAllRegimes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} regimeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regimeControllerFindOneRegime(regimeId: number, options?: any): AxiosPromise<RegimeControllerFindOneRegime200Response> {
            return localVarFp.regimeControllerFindOneRegime(regimeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegimenFiscalApi - object-oriented interface
 * @export
 * @class RegimenFiscalApi
 * @extends {BaseAPI}
 */
export class RegimenFiscalApi extends BaseAPI {
    /**
     * Obtener un listado de los regimen fiscales que existen en base de datos
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegimenFiscalApi
     */
    public regimeControllerFindAllRegimes(options?: AxiosRequestConfig) {
        return RegimenFiscalApiFp(this.configuration).regimeControllerFindAllRegimes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} regimeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegimenFiscalApi
     */
    public regimeControllerFindOneRegime(regimeId: number, options?: AxiosRequestConfig) {
        return RegimenFiscalApiFp(this.configuration).regimeControllerFindOneRegime(regimeId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create users, email is unique
         * @summary 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerCreateUser: async (createUserDto: CreateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('usersControllerCreateUser', 'createUserDto', createUserDto)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * obtener un listado de todos los usuarios del sistema, con filtro de usuarios inactivos
         * @summary 
         * @param {0 | 1} [inactive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindAll: async (inactive?: 0 | 1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (inactive !== undefined) {
                localVarQueryParameter['inactive'] = inactive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * e¿obtener todos los datos de un usuario
         * @summary 
         * @param {number} userId 
         * @param {0 | 1} [inactive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindOne: async (userId: number, inactive?: 0 | 1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersControllerFindOne', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (inactive !== undefined) {
                localVarQueryParameter['inactive'] = inactive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerForceRemoveUser: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersControllerForceRemoveUser', 'userId', userId)
            const localVarPath = `/users/{userId}/destroy`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * generar una nueva contraseña para un usuario
         * @summary 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerRegeneratePasswordUser: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersControllerRegeneratePasswordUser', 'userId', userId)
            const localVarPath = `/users/{userId}/password`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerRestoreUser: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersControllerRestoreUser', 'userId', userId)
            const localVarPath = `/users/{userId}/restore`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerSoftRemoveUser: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersControllerSoftRemoveUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * actualizar un usuario dado su id, con un body de los datos a actualizar
         * @summary 
         * @param {number} userId 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUpdateUser: async (userId: number, createUserDto: CreateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersControllerUpdateUser', 'userId', userId)
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('usersControllerUpdateUser', 'createUserDto', createUserDto)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * create users, email is unique
         * @summary 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerCreateUser(createUserDto: CreateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersControllerCreateUser201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerCreateUser(createUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * obtener un listado de todos los usuarios del sistema, con filtro de usuarios inactivos
         * @summary 
         * @param {0 | 1} [inactive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerFindAll(inactive?: 0 | 1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersControllerFindAll200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFindAll(inactive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * e¿obtener todos los datos de un usuario
         * @summary 
         * @param {number} userId 
         * @param {0 | 1} [inactive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerFindOne(userId: number, inactive?: 0 | 1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFindOne(userId, inactive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerForceRemoveUser(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerForceRemoveUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * generar una nueva contraseña para un usuario
         * @summary 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerRegeneratePasswordUser(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersControllerCreateUser201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerRegeneratePasswordUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerRestoreUser(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerRestoreUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerSoftRemoveUser(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerSoftRemoveUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * actualizar un usuario dado su id, con un body de los datos a actualizar
         * @summary 
         * @param {number} userId 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerUpdateUser(userId: number, createUserDto: CreateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerUpdateUser(userId, createUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * create users, email is unique
         * @summary 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerCreateUser(createUserDto: CreateUserDto, options?: any): AxiosPromise<UsersControllerCreateUser201Response> {
            return localVarFp.usersControllerCreateUser(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * obtener un listado de todos los usuarios del sistema, con filtro de usuarios inactivos
         * @summary 
         * @param {0 | 1} [inactive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindAll(inactive?: 0 | 1, options?: any): AxiosPromise<UsersControllerFindAll200Response> {
            return localVarFp.usersControllerFindAll(inactive, options).then((request) => request(axios, basePath));
        },
        /**
         * e¿obtener todos los datos de un usuario
         * @summary 
         * @param {number} userId 
         * @param {0 | 1} [inactive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindOne(userId: number, inactive?: 0 | 1, options?: any): AxiosPromise<UsersControllerFindOne200Response> {
            return localVarFp.usersControllerFindOne(userId, inactive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerForceRemoveUser(userId: number, options?: any): AxiosPromise<UsersControllerFindOne200Response> {
            return localVarFp.usersControllerForceRemoveUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * generar una nueva contraseña para un usuario
         * @summary 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerRegeneratePasswordUser(userId: number, options?: any): AxiosPromise<UsersControllerCreateUser201Response> {
            return localVarFp.usersControllerRegeneratePasswordUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerRestoreUser(userId: number, options?: any): AxiosPromise<UsersControllerFindOne200Response> {
            return localVarFp.usersControllerRestoreUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerSoftRemoveUser(userId: number, options?: any): AxiosPromise<UsersControllerFindOne200Response> {
            return localVarFp.usersControllerSoftRemoveUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * actualizar un usuario dado su id, con un body de los datos a actualizar
         * @summary 
         * @param {number} userId 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUpdateUser(userId: number, createUserDto: CreateUserDto, options?: any): AxiosPromise<UsersControllerFindOne200Response> {
            return localVarFp.usersControllerUpdateUser(userId, createUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * create users, email is unique
     * @summary 
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerCreateUser(createUserDto: CreateUserDto, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerCreateUser(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * obtener un listado de todos los usuarios del sistema, con filtro de usuarios inactivos
     * @summary 
     * @param {0 | 1} [inactive] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerFindAll(inactive?: 0 | 1, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerFindAll(inactive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * e¿obtener todos los datos de un usuario
     * @summary 
     * @param {number} userId 
     * @param {0 | 1} [inactive] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerFindOne(userId: number, inactive?: 0 | 1, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerFindOne(userId, inactive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerForceRemoveUser(userId: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerForceRemoveUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * generar una nueva contraseña para un usuario
     * @summary 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerRegeneratePasswordUser(userId: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerRegeneratePasswordUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerRestoreUser(userId: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerRestoreUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerSoftRemoveUser(userId: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerSoftRemoveUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * actualizar un usuario dado su id, con un body de los datos a actualizar
     * @summary 
     * @param {number} userId 
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerUpdateUser(userId: number, createUserDto: CreateUserDto, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerUpdateUser(userId, createUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


