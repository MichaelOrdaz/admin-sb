/* tslint:disable */
/* eslint-disable */
/**
 * SB documentacion
 * Documentacion para api resful s&b
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface Activity
 */
export interface Activity {
  /**
   *
   * @type {number}
   * @memberof Activity
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  name: string
  /**
   *
   * @type {number}
   * @memberof Activity
   */
  percentage: number
  /**
   *
   * @type {Client}
   * @memberof Activity
   */
  client?: Client
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  createdAt: string
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  updatedAt: string
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  deletedAt?: string
}
/**
 *
 * @export
 * @interface AuthControllerLogin200Response
 */
export interface AuthControllerLogin200Response {
  /**
   *
   * @type {AuthControllerLogin200ResponseData}
   * @memberof AuthControllerLogin200Response
   */
  data?: AuthControllerLogin200ResponseData
}
/**
 *
 * @export
 * @interface AuthControllerLogin200ResponseData
 */
export interface AuthControllerLogin200ResponseData {
  /**
   *
   * @type {User}
   * @memberof AuthControllerLogin200ResponseData
   */
  user?: User
  /**
   *
   * @type {string}
   * @memberof AuthControllerLogin200ResponseData
   */
  access_token?: string
}
/**
 *
 * @export
 * @interface Client
 */
export interface Client {
  /**
   *
   * @type {number}
   * @memberof Client
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof Client
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  paternalSurname?: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  maternalSurname?: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  phone2?: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  rfc: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  curp?: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  street?: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  outdoorNumber?: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  interiorNumber?: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  cologne?: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  postalCode?: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  province?: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  state: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  legalRepresentativeFullname?: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  legalRepresentativeRFC?: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  legalRepresentativeCURP?: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  observations: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  reasonToInactive: string
  /**
   *
   * @type {Array<Activity>}
   * @memberof Client
   */
  activities?: Array<Activity>
  /**
   *
   * @type {Array<Regime>}
   * @memberof Client
   */
  regimes?: Array<Regime>
  /**
   *
   * @type {string}
   * @memberof Client
   */
  createdAt: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  updatedAt: string
  /**
   *
   * @type {string}
   * @memberof Client
   */
  deletedAt?: string
}
/**
 *
 * @export
 * @interface ClientActivitiesDto
 */
export interface ClientActivitiesDto {
  /**
   *
   * @type {number}
   * @memberof ClientActivitiesDto
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof ClientActivitiesDto
   */
  name: string
  /**
   *
   * @type {number}
   * @memberof ClientActivitiesDto
   */
  percentage: number
}
/**
 *
 * @export
 * @interface ClientsControllerCreateClient201Response
 */
export interface ClientsControllerCreateClient201Response {
  /**
   *
   * @type {ClientsControllerCreateClient201ResponseData}
   * @memberof ClientsControllerCreateClient201Response
   */
  data?: ClientsControllerCreateClient201ResponseData
}
/**
 *
 * @export
 * @interface ClientsControllerCreateClient201ResponseData
 */
export interface ClientsControllerCreateClient201ResponseData {
  /**
   *
   * @type {Client}
   * @memberof ClientsControllerCreateClient201ResponseData
   */
  client?: Client
}
/**
 *
 * @export
 * @interface ClientsControllerFindClients200Response
 */
export interface ClientsControllerFindClients200Response {
  /**
   *
   * @type {ClientsControllerFindClients200ResponseData}
   * @memberof ClientsControllerFindClients200Response
   */
  data?: ClientsControllerFindClients200ResponseData
}
/**
 *
 * @export
 * @interface ClientsControllerFindClients200ResponseData
 */
export interface ClientsControllerFindClients200ResponseData {
  /**
   *
   * @type {Array<Client>}
   * @memberof ClientsControllerFindClients200ResponseData
   */
  clients?: Array<Client>
}
/**
 *
 * @export
 * @interface CreateClientDto
 */
export interface CreateClientDto {
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  paternalSurname?: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  maternalSurname?: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  phone2?: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  rfc: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  curp?: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  street?: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  outdoorNumber?: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  interiorNumber?: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  cologne?: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  postalCode?: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  province?: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  state: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  legalRepresentativeFullname?: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  legalRepresentativeRFC?: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  legalRepresentativeCURP?: string
  /**
   *
   * @type {string}
   * @memberof CreateClientDto
   */
  observations?: string
  /**
   *
   * @type {Array<number>}
   * @memberof CreateClientDto
   */
  regimes: Array<number>
  /**
   *
   * @type {Array<ClientActivitiesDto>}
   * @memberof CreateClientDto
   */
  activities: Array<ClientActivitiesDto>
}
/**
 *
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
  /**
   *
   * @type {string}
   * @memberof CreateUserDto
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof CreateUserDto
   */
  paternalSurname?: string
  /**
   *
   * @type {string}
   * @memberof CreateUserDto
   */
  maternalSurname?: string
  /**
   *
   * @type {string}
   * @memberof CreateUserDto
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof CreateUserDto
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof CreateUserDto
   */
  role: string
}
/**
 *
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
  /**
   *
   * @type {string}
   * @memberof LoginDto
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof LoginDto
   */
  password: string
}
/**
 *
 * @export
 * @interface Regime
 */
export interface Regime {
  /**
   *
   * @type {number}
   * @memberof Regime
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof Regime
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Regime
   */
  key?: string
  /**
   *
   * @type {Array<Client>}
   * @memberof Regime
   */
  clients?: Array<Client>
  /**
   *
   * @type {string}
   * @memberof Regime
   */
  createdAt: string
  /**
   *
   * @type {string}
   * @memberof Regime
   */
  updatedAt: string
  /**
   *
   * @type {string}
   * @memberof Regime
   */
  deletedAt?: string
}
/**
 *
 * @export
 * @interface RegimeControllerFindAllRegimes200Response
 */
export interface RegimeControllerFindAllRegimes200Response {
  /**
   *
   * @type {RegimeControllerFindAllRegimes200ResponseData}
   * @memberof RegimeControllerFindAllRegimes200Response
   */
  data?: RegimeControllerFindAllRegimes200ResponseData
}
/**
 *
 * @export
 * @interface RegimeControllerFindAllRegimes200ResponseData
 */
export interface RegimeControllerFindAllRegimes200ResponseData {
  /**
   *
   * @type {Array<Regime>}
   * @memberof RegimeControllerFindAllRegimes200ResponseData
   */
  regimes?: Array<Regime>
}
/**
 *
 * @export
 * @interface RegimeControllerFindOneRegime200Response
 */
export interface RegimeControllerFindOneRegime200Response {
  /**
   *
   * @type {RegimeControllerFindOneRegime200ResponseData}
   * @memberof RegimeControllerFindOneRegime200Response
   */
  data?: RegimeControllerFindOneRegime200ResponseData
}
/**
 *
 * @export
 * @interface RegimeControllerFindOneRegime200ResponseData
 */
export interface RegimeControllerFindOneRegime200ResponseData {
  /**
   *
   * @type {Regime}
   * @memberof RegimeControllerFindOneRegime200ResponseData
   */
  regime?: Regime
}
/**
 *
 * @export
 * @interface SoftDeleteClientDto
 */
export interface SoftDeleteClientDto {
  /**
   *
   * @type {string}
   * @memberof SoftDeleteClientDto
   */
  reason: string
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {number}
   * @memberof User
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof User
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  paternalSurname: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  maternalSurname?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  password: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  role: string
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  active?: boolean
  /**
   *
   * @type {string}
   * @memberof User
   */
  createdAt: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  updatedAt: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  deletedAt: string
}
/**
 *
 * @export
 * @interface UsersControllerCreateUser201Response
 */
export interface UsersControllerCreateUser201Response {
  /**
   *
   * @type {UsersControllerCreateUser201ResponseData}
   * @memberof UsersControllerCreateUser201Response
   */
  data?: UsersControllerCreateUser201ResponseData
}
/**
 *
 * @export
 * @interface UsersControllerCreateUser201ResponseData
 */
export interface UsersControllerCreateUser201ResponseData {
  /**
   *
   * @type {User}
   * @memberof UsersControllerCreateUser201ResponseData
   */
  user?: User
  /**
   *
   * @type {string}
   * @memberof UsersControllerCreateUser201ResponseData
   */
  password?: string
}
/**
 *
 * @export
 * @interface UsersControllerFindAll200Response
 */
export interface UsersControllerFindAll200Response {
  /**
   *
   * @type {UsersControllerFindAll200ResponseData}
   * @memberof UsersControllerFindAll200Response
   */
  data?: UsersControllerFindAll200ResponseData
}
/**
 *
 * @export
 * @interface UsersControllerFindAll200ResponseData
 */
export interface UsersControllerFindAll200ResponseData {
  /**
   *
   * @type {Array<User>}
   * @memberof UsersControllerFindAll200ResponseData
   */
  users?: Array<User>
}
/**
 *
 * @export
 * @interface UsersControllerFindAll400Response
 */
export interface UsersControllerFindAll400Response {
  /**
   *
   * @type {number}
   * @memberof UsersControllerFindAll400Response
   */
  statusCode?: number
  /**
   *
   * @type {UsersControllerFindAll400ResponseMessage}
   * @memberof UsersControllerFindAll400Response
   */
  message?: UsersControllerFindAll400ResponseMessage
  /**
   *
   * @type {string}
   * @memberof UsersControllerFindAll400Response
   */
  error?: string
}
/**
 *
 * @export
 * @interface UsersControllerFindAll400ResponseMessage
 */
export interface UsersControllerFindAll400ResponseMessage {}
/**
 *
 * @export
 * @interface UsersControllerFindOne200Response
 */
export interface UsersControllerFindOne200Response {
  /**
   *
   * @type {UsersControllerFindOne200ResponseData}
   * @memberof UsersControllerFindOne200Response
   */
  data?: UsersControllerFindOne200ResponseData
}
/**
 *
 * @export
 * @interface UsersControllerFindOne200ResponseData
 */
export interface UsersControllerFindOne200ResponseData {
  /**
   *
   * @type {User}
   * @memberof UsersControllerFindOne200ResponseData
   */
  user?: User
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * endpoint para probar que cualquier rol puede acceder a el
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerBothRoles: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/all`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * endpoint para obtener los datos del usuario en sesion
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerGetProfile: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/me`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * endpoint para autenticacion de usuario, se espera recibir un email y un password en el body de tipo json
     * @summary
     * @param {LoginDto} loginDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogin: async (
      loginDto: LoginDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginDto' is not null or undefined
      assertParamExists('authControllerLogin', 'loginDto', loginDto)
      const localVarPath = `/auth/login`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * endpoint test permitido solo a usuarios con rol administrador
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerOnlyAdmin: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/admin`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * endpoint test permitido solo a usuarios con rol operativo
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerOnlyOperativo: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/operational`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     * endpoint para probar que cualquier rol puede acceder a el
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerBothRoles(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authControllerBothRoles(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * endpoint para obtener los datos del usuario en sesion
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerGetProfile(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UsersControllerFindOne200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authControllerGetProfile(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * endpoint para autenticacion de usuario, se espera recibir un email y un password en el body de tipo json
     * @summary
     * @param {LoginDto} loginDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerLogin(
      loginDto: LoginDto,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AuthControllerLogin200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authControllerLogin(loginDto, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * endpoint test permitido solo a usuarios con rol administrador
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerOnlyAdmin(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authControllerOnlyAdmin(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * endpoint test permitido solo a usuarios con rol operativo
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerOnlyOperativo(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authControllerOnlyOperativo(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     * endpoint para probar que cualquier rol puede acceder a el
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerBothRoles(options?: any): AxiosPromise<void> {
      return localVarFp
        .authControllerBothRoles(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * endpoint para obtener los datos del usuario en sesion
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerGetProfile(
      options?: any
    ): AxiosPromise<UsersControllerFindOne200Response> {
      return localVarFp
        .authControllerGetProfile(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * endpoint para autenticacion de usuario, se espera recibir un email y un password en el body de tipo json
     * @summary
     * @param {LoginDto} loginDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogin(
      loginDto: LoginDto,
      options?: any
    ): AxiosPromise<AuthControllerLogin200Response> {
      return localVarFp
        .authControllerLogin(loginDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * endpoint test permitido solo a usuarios con rol administrador
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerOnlyAdmin(options?: any): AxiosPromise<void> {
      return localVarFp
        .authControllerOnlyAdmin(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * endpoint test permitido solo a usuarios con rol operativo
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerOnlyOperativo(options?: any): AxiosPromise<void> {
      return localVarFp
        .authControllerOnlyOperativo(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   * endpoint para probar que cualquier rol puede acceder a el
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerBothRoles(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authControllerBothRoles(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * endpoint para obtener los datos del usuario en sesion
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerGetProfile(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authControllerGetProfile(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * endpoint para autenticacion de usuario, se espera recibir un email y un password en el body de tipo json
   * @summary
   * @param {LoginDto} loginDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerLogin(loginDto: LoginDto, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authControllerLogin(loginDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * endpoint test permitido solo a usuarios con rol administrador
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerOnlyAdmin(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authControllerOnlyAdmin(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * endpoint test permitido solo a usuarios con rol operativo
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerOnlyOperativo(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authControllerOnlyOperativo(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ClientesApi - axios parameter creator
 * @export
 */
export const ClientesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Crea un cliente con sus respectivos datos y devuelve el cliente creado
     * @summary
     * @param {CreateClientDto} createClientDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientsControllerCreateClient: async (
      createClientDto: CreateClientDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createClientDto' is not null or undefined
      assertParamExists(
        'clientsControllerCreateClient',
        'createClientDto',
        createClientDto
      )
      const localVarPath = `/clients`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createClientDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Obtiene una lista de clientes registrados en el sistema, con informacion basica
     * @summary
     * @param {0 | 1} [inactive]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientsControllerFindClients: async (
      inactive?: 0 | 1,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/clients`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (inactive !== undefined) {
        localVarQueryParameter['inactive'] = inactive
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * obtener todos los datos del un cliente en particular
     * @summary
     * @param {number} clientId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientsControllerFindOneClient: async (
      clientId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'clientId' is not null or undefined
      assertParamExists('clientsControllerFindOneClient', 'clientId', clientId)
      const localVarPath = `/clients/{clientId}`.replace(
        `{${'clientId'}}`,
        encodeURIComponent(String(clientId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Elimina un cliente por id por completo de la base de datos
     * @summary
     * @param {number} clientId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientsControllerForceRemoveClient: async (
      clientId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'clientId' is not null or undefined
      assertParamExists(
        'clientsControllerForceRemoveClient',
        'clientId',
        clientId
      )
      const localVarPath = `/clients/{clientId}/destroy`.replace(
        `{${'clientId'}}`,
        encodeURIComponent(String(clientId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * reestablece un cliente que fue eliminado temporalmente
     * @summary
     * @param {number} clientId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientsControllerRestoreClient: async (
      clientId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'clientId' is not null or undefined
      assertParamExists('clientsControllerRestoreClient', 'clientId', clientId)
      const localVarPath = `/clients/{clientId}/restore`.replace(
        `{${'clientId'}}`,
        encodeURIComponent(String(clientId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Elimina un cliente por id, se conservan sus datos (borrado logico)
     * @summary
     * @param {number} clientId
     * @param {SoftDeleteClientDto} softDeleteClientDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientsControllerSoftRemoveClient: async (
      clientId: number,
      softDeleteClientDto: SoftDeleteClientDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'clientId' is not null or undefined
      assertParamExists(
        'clientsControllerSoftRemoveClient',
        'clientId',
        clientId
      )
      // verify required parameter 'softDeleteClientDto' is not null or undefined
      assertParamExists(
        'clientsControllerSoftRemoveClient',
        'softDeleteClientDto',
        softDeleteClientDto
      )
      const localVarPath = `/clients/{clientId}`.replace(
        `{${'clientId'}}`,
        encodeURIComponent(String(clientId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        softDeleteClientDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Actualiza los datos de un cliente
     * @summary
     * @param {number} clientId
     * @param {CreateClientDto} createClientDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientsControllerUpdateClient: async (
      clientId: number,
      createClientDto: CreateClientDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'clientId' is not null or undefined
      assertParamExists('clientsControllerUpdateClient', 'clientId', clientId)
      // verify required parameter 'createClientDto' is not null or undefined
      assertParamExists(
        'clientsControllerUpdateClient',
        'createClientDto',
        createClientDto
      )
      const localVarPath = `/clients/{clientId}`.replace(
        `{${'clientId'}}`,
        encodeURIComponent(String(clientId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createClientDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ClientesApi - functional programming interface
 * @export
 */
export const ClientesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ClientesApiAxiosParamCreator(configuration)
  return {
    /**
     * Crea un cliente con sus respectivos datos y devuelve el cliente creado
     * @summary
     * @param {CreateClientDto} createClientDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clientsControllerCreateClient(
      createClientDto: CreateClientDto,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientsControllerCreateClient201Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.clientsControllerCreateClient(
          createClientDto,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Obtiene una lista de clientes registrados en el sistema, con informacion basica
     * @summary
     * @param {0 | 1} [inactive]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clientsControllerFindClients(
      inactive?: 0 | 1,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientsControllerFindClients200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.clientsControllerFindClients(
          inactive,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * obtener todos los datos del un cliente en particular
     * @summary
     * @param {number} clientId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clientsControllerFindOneClient(
      clientId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientsControllerCreateClient201Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.clientsControllerFindOneClient(
          clientId,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Elimina un cliente por id por completo de la base de datos
     * @summary
     * @param {number} clientId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clientsControllerForceRemoveClient(
      clientId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientsControllerCreateClient201Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.clientsControllerForceRemoveClient(
          clientId,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * reestablece un cliente que fue eliminado temporalmente
     * @summary
     * @param {number} clientId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clientsControllerRestoreClient(
      clientId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientsControllerCreateClient201Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.clientsControllerRestoreClient(
          clientId,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Elimina un cliente por id, se conservan sus datos (borrado logico)
     * @summary
     * @param {number} clientId
     * @param {SoftDeleteClientDto} softDeleteClientDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clientsControllerSoftRemoveClient(
      clientId: number,
      softDeleteClientDto: SoftDeleteClientDto,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientsControllerCreateClient201Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.clientsControllerSoftRemoveClient(
          clientId,
          softDeleteClientDto,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Actualiza los datos de un cliente
     * @summary
     * @param {number} clientId
     * @param {CreateClientDto} createClientDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clientsControllerUpdateClient(
      clientId: number,
      createClientDto: CreateClientDto,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientsControllerCreateClient201Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.clientsControllerUpdateClient(
          clientId,
          createClientDto,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ClientesApi - factory interface
 * @export
 */
export const ClientesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ClientesApiFp(configuration)
  return {
    /**
     * Crea un cliente con sus respectivos datos y devuelve el cliente creado
     * @summary
     * @param {CreateClientDto} createClientDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientsControllerCreateClient(
      createClientDto: CreateClientDto,
      options?: any
    ): AxiosPromise<ClientsControllerCreateClient201Response> {
      return localVarFp
        .clientsControllerCreateClient(createClientDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Obtiene una lista de clientes registrados en el sistema, con informacion basica
     * @summary
     * @param {0 | 1} [inactive]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientsControllerFindClients(
      inactive?: 0 | 1,
      options?: any
    ): AxiosPromise<ClientsControllerFindClients200Response> {
      return localVarFp
        .clientsControllerFindClients(inactive, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * obtener todos los datos del un cliente en particular
     * @summary
     * @param {number} clientId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientsControllerFindOneClient(
      clientId: number,
      options?: any
    ): AxiosPromise<ClientsControllerCreateClient201Response> {
      return localVarFp
        .clientsControllerFindOneClient(clientId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Elimina un cliente por id por completo de la base de datos
     * @summary
     * @param {number} clientId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientsControllerForceRemoveClient(
      clientId: number,
      options?: any
    ): AxiosPromise<ClientsControllerCreateClient201Response> {
      return localVarFp
        .clientsControllerForceRemoveClient(clientId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * reestablece un cliente que fue eliminado temporalmente
     * @summary
     * @param {number} clientId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientsControllerRestoreClient(
      clientId: number,
      options?: any
    ): AxiosPromise<ClientsControllerCreateClient201Response> {
      return localVarFp
        .clientsControllerRestoreClient(clientId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Elimina un cliente por id, se conservan sus datos (borrado logico)
     * @summary
     * @param {number} clientId
     * @param {SoftDeleteClientDto} softDeleteClientDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientsControllerSoftRemoveClient(
      clientId: number,
      softDeleteClientDto: SoftDeleteClientDto,
      options?: any
    ): AxiosPromise<ClientsControllerCreateClient201Response> {
      return localVarFp
        .clientsControllerSoftRemoveClient(
          clientId,
          softDeleteClientDto,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Actualiza los datos de un cliente
     * @summary
     * @param {number} clientId
     * @param {CreateClientDto} createClientDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientsControllerUpdateClient(
      clientId: number,
      createClientDto: CreateClientDto,
      options?: any
    ): AxiosPromise<ClientsControllerCreateClient201Response> {
      return localVarFp
        .clientsControllerUpdateClient(clientId, createClientDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ClientesApi - object-oriented interface
 * @export
 * @class ClientesApi
 * @extends {BaseAPI}
 */
export class ClientesApi extends BaseAPI {
  /**
   * Crea un cliente con sus respectivos datos y devuelve el cliente creado
   * @summary
   * @param {CreateClientDto} createClientDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientesApi
   */
  public clientsControllerCreateClient(
    createClientDto: CreateClientDto,
    options?: AxiosRequestConfig
  ) {
    return ClientesApiFp(this.configuration)
      .clientsControllerCreateClient(createClientDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Obtiene una lista de clientes registrados en el sistema, con informacion basica
   * @summary
   * @param {0 | 1} [inactive]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientesApi
   */
  public clientsControllerFindClients(
    inactive?: 0 | 1,
    options?: AxiosRequestConfig
  ) {
    return ClientesApiFp(this.configuration)
      .clientsControllerFindClients(inactive, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * obtener todos los datos del un cliente en particular
   * @summary
   * @param {number} clientId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientesApi
   */
  public clientsControllerFindOneClient(
    clientId: number,
    options?: AxiosRequestConfig
  ) {
    return ClientesApiFp(this.configuration)
      .clientsControllerFindOneClient(clientId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Elimina un cliente por id por completo de la base de datos
   * @summary
   * @param {number} clientId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientesApi
   */
  public clientsControllerForceRemoveClient(
    clientId: number,
    options?: AxiosRequestConfig
  ) {
    return ClientesApiFp(this.configuration)
      .clientsControllerForceRemoveClient(clientId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * reestablece un cliente que fue eliminado temporalmente
   * @summary
   * @param {number} clientId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientesApi
   */
  public clientsControllerRestoreClient(
    clientId: number,
    options?: AxiosRequestConfig
  ) {
    return ClientesApiFp(this.configuration)
      .clientsControllerRestoreClient(clientId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Elimina un cliente por id, se conservan sus datos (borrado logico)
   * @summary
   * @param {number} clientId
   * @param {SoftDeleteClientDto} softDeleteClientDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientesApi
   */
  public clientsControllerSoftRemoveClient(
    clientId: number,
    softDeleteClientDto: SoftDeleteClientDto,
    options?: AxiosRequestConfig
  ) {
    return ClientesApiFp(this.configuration)
      .clientsControllerSoftRemoveClient(clientId, softDeleteClientDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Actualiza los datos de un cliente
   * @summary
   * @param {number} clientId
   * @param {CreateClientDto} createClientDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientesApi
   */
  public clientsControllerUpdateClient(
    clientId: number,
    createClientDto: CreateClientDto,
    options?: AxiosRequestConfig
  ) {
    return ClientesApiFp(this.configuration)
      .clientsControllerUpdateClient(clientId, createClientDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RegimenFiscalApi - axios parameter creator
 * @export
 */
export const RegimenFiscalApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Obtener un listado de los regimen fiscales que existen en base de datos
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    regimeControllerFindAllRegimes: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/regimes`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} regimeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    regimeControllerFindOneRegime: async (
      regimeId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'regimeId' is not null or undefined
      assertParamExists('regimeControllerFindOneRegime', 'regimeId', regimeId)
      const localVarPath = `/regimes/{regimeId}`.replace(
        `{${'regimeId'}}`,
        encodeURIComponent(String(regimeId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RegimenFiscalApi - functional programming interface
 * @export
 */
export const RegimenFiscalApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    RegimenFiscalApiAxiosParamCreator(configuration)
  return {
    /**
     * Obtener un listado de los regimen fiscales que existen en base de datos
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async regimeControllerFindAllRegimes(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RegimeControllerFindAllRegimes200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.regimeControllerFindAllRegimes(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} regimeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async regimeControllerFindOneRegime(
      regimeId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RegimeControllerFindOneRegime200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.regimeControllerFindOneRegime(
          regimeId,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * RegimenFiscalApi - factory interface
 * @export
 */
export const RegimenFiscalApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RegimenFiscalApiFp(configuration)
  return {
    /**
     * Obtener un listado de los regimen fiscales que existen en base de datos
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    regimeControllerFindAllRegimes(
      options?: any
    ): AxiosPromise<RegimeControllerFindAllRegimes200Response> {
      return localVarFp
        .regimeControllerFindAllRegimes(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} regimeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    regimeControllerFindOneRegime(
      regimeId: number,
      options?: any
    ): AxiosPromise<RegimeControllerFindOneRegime200Response> {
      return localVarFp
        .regimeControllerFindOneRegime(regimeId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RegimenFiscalApi - object-oriented interface
 * @export
 * @class RegimenFiscalApi
 * @extends {BaseAPI}
 */
export class RegimenFiscalApi extends BaseAPI {
  /**
   * Obtener un listado de los regimen fiscales que existen en base de datos
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegimenFiscalApi
   */
  public regimeControllerFindAllRegimes(options?: AxiosRequestConfig) {
    return RegimenFiscalApiFp(this.configuration)
      .regimeControllerFindAllRegimes(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} regimeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegimenFiscalApi
   */
  public regimeControllerFindOneRegime(
    regimeId: number,
    options?: AxiosRequestConfig
  ) {
    return RegimenFiscalApiFp(this.configuration)
      .regimeControllerFindOneRegime(regimeId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * create users, email is unique
     * @summary
     * @param {CreateUserDto} createUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerCreateUser: async (
      createUserDto: CreateUserDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createUserDto' is not null or undefined
      assertParamExists(
        'usersControllerCreateUser',
        'createUserDto',
        createUserDto
      )
      const localVarPath = `/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createUserDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * obtener un listado de todos los usuarios del sistema, con filtro de usuarios inactivos
     * @summary
     * @param {0 | 1} [inactive]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerFindAll: async (
      inactive?: 0 | 1,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (inactive !== undefined) {
        localVarQueryParameter['inactive'] = inactive
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * e¿obtener todos los datos de un usuario
     * @summary
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerFindOne: async (
      userId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('usersControllerFindOne', 'userId', userId)
      const localVarPath = `/users/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerForceRemoveUser: async (
      userId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('usersControllerForceRemoveUser', 'userId', userId)
      const localVarPath = `/users/{userId}/destroy`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * generar una nueva contraseña para un usuario
     * @summary
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerRegeneratePasswordUser: async (
      userId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists(
        'usersControllerRegeneratePasswordUser',
        'userId',
        userId
      )
      const localVarPath = `/users/{userId}/password`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerRestoreUser: async (
      userId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('usersControllerRestoreUser', 'userId', userId)
      const localVarPath = `/users/{userId}/restore`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerSoftRemoveUser: async (
      userId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('usersControllerSoftRemoveUser', 'userId', userId)
      const localVarPath = `/users/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * actualizar un usuario dado su id, con un body de los datos a actualizar
     * @summary
     * @param {number} userId
     * @param {CreateUserDto} createUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerUpdateUser: async (
      userId: number,
      createUserDto: CreateUserDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('usersControllerUpdateUser', 'userId', userId)
      // verify required parameter 'createUserDto' is not null or undefined
      assertParamExists(
        'usersControllerUpdateUser',
        'createUserDto',
        createUserDto
      )
      const localVarPath = `/users/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createUserDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
  return {
    /**
     * create users, email is unique
     * @summary
     * @param {CreateUserDto} createUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerCreateUser(
      createUserDto: CreateUserDto,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UsersControllerCreateUser201Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerCreateUser(
          createUserDto,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * obtener un listado de todos los usuarios del sistema, con filtro de usuarios inactivos
     * @summary
     * @param {0 | 1} [inactive]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerFindAll(
      inactive?: 0 | 1,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UsersControllerFindAll200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerFindAll(
          inactive,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * e¿obtener todos los datos de un usuario
     * @summary
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerFindOne(
      userId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UsersControllerFindOne200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerFindOne(userId, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerForceRemoveUser(
      userId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UsersControllerFindOne200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerForceRemoveUser(
          userId,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * generar una nueva contraseña para un usuario
     * @summary
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerRegeneratePasswordUser(
      userId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UsersControllerCreateUser201Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerRegeneratePasswordUser(
          userId,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerRestoreUser(
      userId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UsersControllerFindOne200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerRestoreUser(
          userId,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerSoftRemoveUser(
      userId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UsersControllerFindOne200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerSoftRemoveUser(
          userId,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * actualizar un usuario dado su id, con un body de los datos a actualizar
     * @summary
     * @param {number} userId
     * @param {CreateUserDto} createUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerUpdateUser(
      userId: number,
      createUserDto: CreateUserDto,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UsersControllerFindOne200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerUpdateUser(
          userId,
          createUserDto,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration)
  return {
    /**
     * create users, email is unique
     * @summary
     * @param {CreateUserDto} createUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerCreateUser(
      createUserDto: CreateUserDto,
      options?: any
    ): AxiosPromise<UsersControllerCreateUser201Response> {
      return localVarFp
        .usersControllerCreateUser(createUserDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * obtener un listado de todos los usuarios del sistema, con filtro de usuarios inactivos
     * @summary
     * @param {0 | 1} [inactive]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerFindAll(
      inactive?: 0 | 1,
      options?: any
    ): AxiosPromise<UsersControllerFindAll200Response> {
      return localVarFp
        .usersControllerFindAll(inactive, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * e¿obtener todos los datos de un usuario
     * @summary
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerFindOne(
      userId: number,
      options?: any
    ): AxiosPromise<UsersControllerFindOne200Response> {
      return localVarFp
        .usersControllerFindOne(userId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerForceRemoveUser(
      userId: number,
      options?: any
    ): AxiosPromise<UsersControllerFindOne200Response> {
      return localVarFp
        .usersControllerForceRemoveUser(userId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * generar una nueva contraseña para un usuario
     * @summary
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerRegeneratePasswordUser(
      userId: number,
      options?: any
    ): AxiosPromise<UsersControllerCreateUser201Response> {
      return localVarFp
        .usersControllerRegeneratePasswordUser(userId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerRestoreUser(
      userId: number,
      options?: any
    ): AxiosPromise<UsersControllerFindOne200Response> {
      return localVarFp
        .usersControllerRestoreUser(userId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerSoftRemoveUser(
      userId: number,
      options?: any
    ): AxiosPromise<UsersControllerFindOne200Response> {
      return localVarFp
        .usersControllerSoftRemoveUser(userId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * actualizar un usuario dado su id, con un body de los datos a actualizar
     * @summary
     * @param {number} userId
     * @param {CreateUserDto} createUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerUpdateUser(
      userId: number,
      createUserDto: CreateUserDto,
      options?: any
    ): AxiosPromise<UsersControllerFindOne200Response> {
      return localVarFp
        .usersControllerUpdateUser(userId, createUserDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * create users, email is unique
   * @summary
   * @param {CreateUserDto} createUserDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerCreateUser(
    createUserDto: CreateUserDto,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .usersControllerCreateUser(createUserDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * obtener un listado de todos los usuarios del sistema, con filtro de usuarios inactivos
   * @summary
   * @param {0 | 1} [inactive]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerFindAll(
    inactive?: 0 | 1,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .usersControllerFindAll(inactive, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * e¿obtener todos los datos de un usuario
   * @summary
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerFindOne(userId: number, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .usersControllerFindOne(userId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerForceRemoveUser(
    userId: number,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .usersControllerForceRemoveUser(userId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * generar una nueva contraseña para un usuario
   * @summary
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerRegeneratePasswordUser(
    userId: number,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .usersControllerRegeneratePasswordUser(userId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerRestoreUser(
    userId: number,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .usersControllerRestoreUser(userId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerSoftRemoveUser(
    userId: number,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .usersControllerSoftRemoveUser(userId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * actualizar un usuario dado su id, con un body de los datos a actualizar
   * @summary
   * @param {number} userId
   * @param {CreateUserDto} createUserDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerUpdateUser(
    userId: number,
    createUserDto: CreateUserDto,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .usersControllerUpdateUser(userId, createUserDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
